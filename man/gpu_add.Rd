% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gpu_add.R
\name{gpu_add}
\alias{gpu_add}
\title{GPU-accelerated Vector Addition}
\usage{
gpu_add(a, b, force_cpu = FALSE, warn_fallback = TRUE)
}
\arguments{
\item{a}{A numeric vector}

\item{b}{A numeric vector of the same length as \code{a}}

\item{force_cpu}{Logical. If TRUE, forces CPU implementation (for testing/fallback)}

\item{warn_fallback}{Logical. If TRUE, warns when falling back to CPU implementation}
}
\value{
A numeric vector containing the element-wise sum of \code{a} and \code{b}
}
\description{
Performs element-wise addition of two numeric vectors using CUDA on the GPU.
This function provides a GPU-accelerated alternative to the standard R `+` operator
for large vectors where the computational overhead of GPU memory transfer is 
justified by the parallel processing benefits.
}
\details{
This function transfers the input vectors to GPU memory, performs the addition
using a CUDA kernel with parallel threads, and transfers the result back to CPU.
For small vectors (< 10^4 elements), the CPU version may be faster due to 
memory transfer overhead.

If GPU is not available or GPU operations fail, the function automatically
falls back to CPU computation with an optional warning.

For chained GPU operations or advanced workflows, consider using \code{gpu_tensor()}
to create GPU-resident objects and use the \code{+} operator directly:
\code{tensor_a + tensor_b} where \code{tensor_a} and \code{tensor_b} are gpuTensor objects.
}
\examples{
\dontrun{
# Add two large vectors on GPU (with automatic fallback)
n <- 1e6
a <- runif(n)
b <- runif(n)
result <- gpu_add(a, b)

# Force CPU implementation for testing
result_cpu <- gpu_add(a, b, force_cpu = TRUE)

# For chained operations, use gpuTensor objects:
tensor_a <- gpu_tensor(a, length(a))
tensor_b <- gpu_tensor(b, length(b)) 
tensor_result <- tensor_a + tensor_b  # Stays on GPU
result2 <- as.vector(tensor_result)  # Transfer back when needed

# Verify correctness against CPU
all.equal(result, a + b)
all.equal(result2, a + b)
}

}
