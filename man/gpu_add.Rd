% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gpu_add.R
\name{gpu_add}
\alias{gpu_add}
\title{GPU-accelerated Vector Addition}
\usage{
gpu_add(a, b, use_gpuvector = FALSE)
}
\arguments{
\item{a}{A numeric vector}

\item{b}{A numeric vector of the same length as \code{a}}

\item{use_gpuvector}{Logical. If TRUE, uses the new gpuVector implementation 
which is more efficient for chained operations. Default FALSE for backward compatibility.}
}
\value{
A numeric vector containing the element-wise sum of \code{a} and \code{b}
}
\description{
Performs element-wise addition of two numeric vectors using CUDA on the GPU.
This function provides a GPU-accelerated alternative to the standard R `+` operator
for large vectors where the computational overhead of GPU memory transfer is 
justified by the parallel processing benefits.
}
\details{
This function transfers the input vectors to GPU memory, performs the addition
using a CUDA kernel with parallel threads, and transfers the result back to CPU.
For small vectors (< 10^4 elements), the CPU version may be faster due to 
memory transfer overhead.

When \code{use_gpuvector=TRUE}, the function uses the new gpuVector abstraction
which provides better memory management and is more efficient for sequences of
GPU operations.
}
\examples{
\dontrun{
# Add two large vectors on GPU (original method)
n <- 1e6
a <- runif(n)
b <- runif(n)
result <- gpu_add(a, b)

# Using new gpuVector implementation
result2 <- gpu_add(a, b, use_gpuvector = TRUE)

# Verify correctness against CPU
all.equal(result, a + b)
all.equal(result2, a + b)
}

}
